\documentclass[answers]{exam}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
% \usepackage{enumitem}
%% Sets page size and margins
\usepackage[a4paper,margin=2cm]{geometry}

%% Useful packages
\usepackage[font=small,labelfont=bf]{caption}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{paralist}
\usepackage{framed}
\usepackage{tikz}
\usepackage{float}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{subfigure}
\tikzset{
  % define the bar graph element
  bar/.pic={
    \fill (-.1,0) rectangle (.1,#1) (0,#1) node[above,scale=1/2]{$#1$};
  }
}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
% Colored Python listing from https://www.overleaf.com/learn/latex/Code_listing
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

\usetikzlibrary{matrix}

\setlength\FrameSep{4pt}
\title{Probability \& Statistics\\ Project}
\author{Hana Ali Rashid, hr05940\\ Tasmiya Malik, tm06183\\ Ifrah Ilyas, ii06178}
\date{\today{}}
\begin{document}
\maketitle

%--------------------------------  1.2  ------------------------------------
\section*{Q1: Random Walk}
\subsection*{1.1}
In order to simulate a random walk, the following function takes in values of $n$ (number of steps to take), and $p$ (the probability of the object moving one step to the right). It then generates a random number and uses the given probability to determine the direction that the object moves in, and returns the final position.
\lstinputlisting[firstline=5,lastline=13,language=python]{code/q1.py}
The following function uses the \texttt{get\_updated\_position()} function to get 25 outcomes which are then used to calculate a single expected value for the final position. This is repeated 50 times and the histogram of all these expected values is then plotted.
\lstinputlisting[firstline=16,lastline=31,language=python]{code/q1.py}
\pagebreak

\begin{figure}
  \centering
  \mbox{\subfigure[No. of steps taken = 10 with probability of moving a step right = 0.5.]{\includegraphics[scale = 0.35]{Q1/1.1/q1_n = 10_ p = 0.5.png}}\quad
  \subfigure[No. of steps taken = 18 with probability of moving a step right = 0.5.]{\includegraphics[scale = 0.35]{Q1/1.1/q1_n = 18_ p = 0.5.png} }}
\end{figure}
\begin{figure}
  \centering
  \mbox{\subfigure[No. of steps taken = 10 with probability of moving a step right = 0.7.]{\includegraphics[scale = 0.4]{Q1/1.1/q1_n = 10_ p = 0.7.png}}}
\end{figure}

Histograms produced by the above code for expected final positions of objects against frequency, where $n$ is the number of steps taken and $p$ is the probability of the object moving one step to the right.\\
\\
Histograms $(a)$ and $(b)$ have the same value of $p$ and varying number of steps $n$. \\
Both histograms appear to follow a normal distribution, with $(a)$ having a mean of $-0.235$ and a variance of $0.35$ and $(b)$ having a mean of $-0.205$ and a variance of $0.61$. Increasing the number of steps has not had a significant effect on the mean but did increase the variance.\\ \\
Histograms $(a)$ and $(c)$ have the same number of steps $n$ and varying values of $p$. \\
Histogram $(c)$ also appears to follow a normal distribution, having a mean of $3.859$ and a variance of $0.273$. Increasing $p$ appears to have affected the mean of the distribution but not the variance as such.\\


\pagebreak
%--------------------------------  1.2  ------------------------------------
\subsection*{1.2}
The following function is the modified version of the \texttt{get\_updated\_position()} function from the previous part such that the object cannot move into the negative part of the number line.
\lstinputlisting[firstline=34,lastline=42,language=python]{code/q1.py}
The following function uses the \texttt{get\_updated\_position\_restricted()} function to get 25 outcomes which are then used to calculate a single expected value for the final position. This is repeated 50 times and the histogram of all these expected values is then plotted.
\lstinputlisting[firstline=44,lastline=59,language=python]{code/q1.py}
\pagebreak

\begin{figure}
  \centering
  \mbox{\subfigure[No. of steps taken = 20 with probability of moving a step right = 0.5.]{\includegraphics[scale = 0.35]{Q1/1.2/Q1.2 _n = 20_p = 0.5.png}}\quad
  \subfigure[No. of steps taken = 24 with probability of moving a step right = 0.5.]{\includegraphics[scale = 0.35]{Q1/1.2/Q1.2 _n = 24_p = 0.5.png}}}
\end{figure}
\begin{figure}
  \centering
  \mbox{\subfigure[No. of steps taken = 20 with probability of moving a step right = 0.7.]{\includegraphics[scale = 0.35]{Q1/1.2/Q1.2 _n = 20_p = 0.7.png}}\quad
  \subfigure[No. of steps taken = 24 with probability of moving a step right = 0.7.]{\includegraphics[scale = 0.35]{Q1/1.2/Q1.2 _n = 24_p = 0.7.png}}}
\end{figure}

Histograms produced by the above code for expected final positions of objects against frequency, where $n$ is the number of steps taken and $p$ is the probability of the object moving one step to the right.\\
\\
Histograms $(d)$ and $(e)$ have the same value of $p$ and varying number of steps $n$. \\
Both histograms appear to follow a normal distribution, with $(d)$ having a mean of $3.267$ and a variance of $0.233$ and $(e)$ having a mean of $3.466$ and a variance of $0.367$. Again, increasing the number of steps has not had a significant effect on the mean but did increase the variance.\\ \\
Histograms $(f)$ and $(g)$ have the same number of steps $n$ respectively as $(d)$ and $(e)$ and varying values of $p$. 
They also appear to follow a normal distribution, with $(f)$ having a mean of $8.462$ and a variance of $0.559$ and $(g)$ having a mean of $10.187$ and a variance of $0.668$. Increasing $p$ appears to have increased the mean and variance, but the mean has increased more significantly. \\ \\
Additionally, due to the added constraint in this part, we see that no expected value for the final position is negative.

\pagebreak
%--------------------------------  1.3  ------------------------------------
\subsection*{1.3}
In this part, we are required to find the number of steps taken by two objects initialized at different points, and moving randomly to meet. The following function takes in the initial position of both objects $pos1$ and $pos2$ as well as their probabilities $p1$ and $p2$, generates random numbers and determines the number of steps taken to meet.
\lstinputlisting[firstline=61,lastline=75,language=python]{code/q1.py}
The following function uses the \texttt{stepsToMeet} function and calculates 25 expected values using 25 outcomes based on the values of $pos1, pos2, p1$ and $p2$. It then plots a histogram of these expected values as well.
\lstinputlisting[firstline=77,lastline=97,language=python]{code/q1.py}
\pagebreak
Histograms produced by the above code for expected number of steps taken for two objects walking randomly to meet, against frequency:\\

\begin{center}
  \includegraphics[scale = 0.5]{Q1/1.3/Q1.3 _p1 = 0.6_p2 = 0.3_pos1 = -2_pos2 = 4.png}
\end{center}

The above histogram shows that the expected number of steps to meet for two objects follows a normal distribution of mean $10.09$ and variance $1.94$ when they begin 6 steps apart with the given probabilities. \\
\begin{center}\includegraphics[scale = 0.5]{Q1/1.3/Q1.3 _p1 = 0.7_p2 = 0.3_pos1 = -4_pos2 = 4.png}\end{center}
The above histogram shows that the expected number of steps to meet for two objects follows a normal distribution of mean $9.90$ and variance $1.16$ when they begin 8 steps apart with the given probabilities. \\

\newpage
%--------------------------------  2.*  ------------------------------------
\section*{Q2: Simulating Distributions}

%--------------------------------  2.1  ------------------------------------
  \subsection*{2.1}
        It does accomplish as it plots for a value of x (y is the variable expressed in terms of x) against the pdf $e^{-y}$ such that each bar in the histogram shows the probability for an average value of x. The distrubution plotted is a continuous exponential random variable. The number of bins used are significant for our simulation which will become evident with the following images:
        \begin{center}
          \begin{tabular}{cc}
            \includegraphics[width= 0.35\textwidth]{"Q2/bin5.png"}
            \includegraphics[width= 0.36\textwidth]{"Q2/bin20.png"}\\
            \includegraphics[width= 0.375\textwidth]{"Q2/bin100.png"}
            \includegraphics[width= 0.35\textwidth]{"Q2/bin1000.png"}    
          \end{tabular}
          \captionof{figure}{Simulations done with different number of bins} 
        
       
      \end{center} 
      It is noticeable that, with more number of bins, the accuracy of the results increases. However, it is also interesting to note that using 1000 bins almost gives the same result as 100 bins. Therefore, while simulating we need to take an appropriate values for bins for better approximation and less running time.

%--------------------------------  2.2  ------------------------------------
  \subsection*{2.2}  
      In the code we see that :
         $$y=\frac{1}{1-x} $$
         With the trick shown, we can back track to find the original distribution.
        $$1-\frac{1}{y}=x $$
        We know that the upper bound will be y. For the lower bound we see that:
        $$\frac{1}{1}-\frac{1}{y}=x $$
        $$-(\frac{1}{y}-\frac{1}{1})=x $$
        $$\therefore - \frac{1}{y}\Biggr|^{y}_{1}=x $$
        Performing derivative on the left hand side:
        $$\frac{d}{dy} \frac{-1}{y}=(-1)\frac{-1}{y^2}=\frac{1}{y^2}$$
        $$\therefore \int_{1}^{y} \frac{1}{y^2} dy=x$$
        We can affirm that we have reached the right deduction by looking at line 12 of the code.
        So, the distribution of y is :
        $$f_Y(y)=\frac{1}{y^2} for y \geq 1$$
         \lstinputlisting[firstline=23,lastline=25,language=python]{code/Q2.py}
        Lines 5-7 is simply trying to implement a cutoff for values of y greater 30 as values starting to get more smaller. Given that we taken small amount of bins, the average value of each bar becomes negligible and is not visible in the graph. Therefore we cut it down to 30 so that the approximation is more accurate.
     \begin{center}
      \begin{tabular}{cc}
      \includegraphics[width= 0.4\textwidth]{"Q2/beforeremoving.png"}
    \end{tabular}
    \captionof{figure}{Before Removing} 
    \begin{tabular}{cc}
      \includegraphics[width= 0.4\textwidth]{"Q2/afterremoving.png"}
      \includegraphics[width= 0.4\textwidth]{"Q2/afterremoving2.png"} 
    \end{tabular} 
    \captionof{figure}{After Removing} 
    \end{center}
        
%--------------------------------  2.3  ------------------------------------
  \subsection*{2.3}    
    For, $$f_Y (y) = \frac{1}{y^3}
        for y \geq \sqrt{\frac{1}{2}}$$
         $$ P(Y<y)=P(X<x)$$
         $$\int_{\sqrt{\frac{1}{2}}}^{y} \frac{1}{y^3} dy=x$$
         $$ \frac{-1}{2y^2} \Biggr|^{y}_{\sqrt{\frac{1}{2}}}=x$$
         $$ \frac{-1}{2y^2} +\frac{1}{2(\sqrt{\frac{1}{2}})^2}=x$$
         $$ \frac{-1}{2y^2} +1=x$$
         $$ \frac{1}{2y^2} =1-x$$
         $$ y^2=\frac{1}{2(1-x)}$$
         $$ y=\sqrt{\frac{1}{2(1-x)} }$$
         Code:
         \lstinputlisting[firstline=35,lastline=48,language=python]{code/Q2.py}
         The output of simulation for this y:
         \begin{center}
          \begin{tabular}{cc}
          \includegraphics[width= 0.4\textwidth]{"Q2/2.3.png"}
        \end{tabular}
        \captionof{figure}{Simulation of distribution $f_Y (y) = \frac{1}{y^3}
        for y \geq \sqrt{\frac{1}{2}}$} 
      \end{center}
      For the simulation of expected values, the same code used for the above function ran for 10000 times and each run would take the mean of y :
         \lstinputlisting[firstline=51,lastline=62,language=python]{code/Q2.py}
      The output of this simulation:
         \begin{center}
        \begin{tabular}{cc}
        \includegraphics[width= 0.4\textwidth]{"Q2/expected value.png"}
      \end{tabular}
      \captionof{figure}{Simulation of expected values of $fY (y) = \frac{1}{y^3}
      for y \geq \sqrt{\frac{1}{2}}$} 
    \end{center}

\pagebreak
%--------------------------------  3.*  ------------------------------------
\section*{Q3. Picking a Random Point Correctly}

\subsection*{3.1}

\begin{framed}
  For part $3.1$, we followed the method specified in the question. The program takes radius as an input from the user, and passes it to \emph{gen\_points(R)} to display the graph. It first finds random radius R and angle $\theta$, then converts it into cartesian cordinates. It stores the values of x and y till the iterations are running, then plot the points. To make sure the points lie in the given radius, we also draw the circle.
  \begin{itemize}
    \item \emph{polar\_to\_cart(r,t)}: This function takes the polar cordinates $(r \;\text{and}\; \theta)$ and converts them to their cartesian equivalent. It is called from \emph{random\_point(R)}, to return the cartesian cordinates. It uses the following formulae,\\
      \begin{align*}
        x &= r\cos(\theta)\\
        y &= r\sin(\theta)
      \end{align*}

    \item \emph{random\_point(R)}: The function is responsible for generating a random point in polar cordinates, and returns the converted cartesian cordinates.\\
    
    \item \emph{gen\_points(R)}: This is the main function which runs 1000 iterations, and calls \emph{random\_point(R)}, and stores the result in the separate lists for $X$ and $Y$ cordinates. Then the lists are passed to the plot functions, to graph the points.

  \end{itemize}
  The resulting graph has very dense distribution towards the center.
\end{framed}

\lstinputlisting[firstline=1,lastline=48,language=python]{code/Q3(1).py}

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.7]{Q3/Q3(1).png}
\end{figure}
\newpage
%--------------------------------  3.2  ------------------------------------
\subsection*{3.2}
\begin{framed}
  \indent In part $3.2$, we calculated the cartesian cordinates directly from the specified radius R. If the random point lied farther from the distance from the origin, it will be discarded and the program will find a new point.
  \begin{itemize}
    \item \emph{random\_point(R)}: This function finds random points for $x$ and $y$ cordinates between the range $-R$ and $R$. It returns the tuple with cartesian cordinates.\\
    
    \item \emph{dist\_from\_origin(x,y)}: The function find and return the distance of the point from the origin.\\
      \begin{align*}
        dist=\sqrt{x^2+y^2}
      \end{align*}
    \item \emph{gen\_points(R)}: The main function iterates 1000 times and calls \emph{random\_point(R)}. Then it checks the condition that if the distance of the point $(x,y)$ is within the radius $R$, it would append the points to their respective lists, else the counter will be decremented by 1 and the point will not be added to the list. Then the lists $X$ and $Y$ are passed to the plot functions for display.
  \end{itemize}
\end{framed}
\lstinputlisting[firstline=1,lastline=46,language=python]{code/Q3(2).py}
\begin{figure}[h]
  \centering
  \includegraphics[scale=0.7]{Q3/Q3(2).png}
\end{figure}
\newpage
%--------------------------------  3.3  ------------------------------------
\subsection*{3.3}
\begin{framed}
  \indent In part $3.3$, we had to modify the function for polar cordinates, such that the graph it made was uniformly distributed, similar to the histogram of part $3.2$.\\
  \indent The reason behind the uneven distribution when we used polar cordinates was because of the way polar and cartesian planes interact. If we plot points in a smaller radius with varying angles, the points will be closer, as compare to a larger radius. For larger radius the points will be far apart. So when we were converting them into cartesian cordinates, many of them lied near the origin. To solve this, we simply take the CDF, i.e. the area of the circle, and make radius r its subject. Mathematically,\\
  \begin{align*}
    P(r\leq R)&=k.\pi.r^2\\
    \intertext{To find k, we use P(r=R), which is equals to 1.}\\
    k.\pi.R^2&=1\\
    k &= \frac{1}{R^2\pi}\\
    \intertext{Now that we know the value of k, we can find the whole CDF by plugging its value.}\\
    CDF &= (\frac{1}{R^2\pi})(r^2\pi)=\frac{r^2}{R^2}\\
    \intertext{Now we make radius r, the subject of the equation.}\\
    r &= \sqrt{R^2.CDF} = R\sqrt{CDF}
  \end{align*}
  \indent We can find our random radius r using this formula. This will produce the points in proportionality with the area of the circle, thus keeping the point uniform.\\
  \indent From here, we will describe the functionality of the coded program.

  \begin{itemize}
    \item \emph{random\_point(R)}: The function finds random radius R and theta $\theta$. It uses the function for R derived above. 

    \item \emph{polar\_to\_cart(cord)}: This is the same function that we used in part 3.1. The function takes radius r and angle t as the input, and returns the cartesian cordinates. We use the following formulae to derive the cordinates,\\
      \begin{align*}
        x &= r\cos(t)\\
        y &= r\sin(t)
      \end{align*}
    \item \emph{gen\_points(R)}: Like previous parts, this function makes 1000 iterations, and call \emph{random\_point(R)} for each of them, then stores the returned values in their respective lists X and Y.\\
      Then it draws outer and inner circles of the given radius R and $\frac{R}{2}$ respectively, and then plot the points stored in the lists X and Y.
  \end{itemize}
\end{framed}
\lstinputlisting[firstline=1,lastline=53,language=python]{code/Q3(3).py}

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.7]{Q3/Q3(3).png}
\end{figure}
\pagebreak
\section*{Q4. Saying Random is not enough}

%--------------------------------  4.1  ------------------------------------
  \subsection*{4.1}
    \begin{framed}
        For 4.1, we took the approach specified in the question. We first pick two random angles $\theta_1$ and $\theta_2$. Then find their difference to find the angle lying in between $\theta_1$ and $\theta_2$. Then we use this new angle in \emph{cord length} formula. The program does this process 1000 times and stores the values in the specified list, then graphs a histogram for the length of the cords and the probability of them occuring. Following describes each function and their purpose/method for the program.
        \begin{enumerate}
            \item \emph{random\_theta()}: The function finds random $\theta_1$ and $\theta_2$. $\theta$ is chosen randomly from degrees($\phi$) and then converted to radians.
                    \begin{align*}
                        \theta_1 &= \phi_1 . \frac{\pi}{180}\\
                        \theta_2 &= \phi_2 . \frac{\pi}{180}
                    \end{align*}
            \item \emph{cord(R)}: The function takes the radius as the input and returns length of the cord between $\theta_1$ and $\theta_2$. It first calls \emph{random\_theta()}, and find the absolute value of their difference ($\theta=|\theta_1 - \theta_2|$). Then the length of the cord in calculated using the following formula for cord length,
                    $$\text{cord length}=2R.\sin(\theta/2)$$
            \item \emph{find\_cords1(R)}: The function takes radius R as input, then draw the histogram as the output. It iterates 1000 times, calls \emph{cord(R)} for each iteration and append the result in \emph{cord\_len}. The bin value is set to be 50 as it provides a good threshold for the 1000 values. Then it plots the graph using matplotlib.
        \end{enumerate}
    \end{framed}
    \lstinputlisting[firstline=5,lastline=34,language=python]{code/Q4.py}
    \begin{figure}[ht]
        \caption{Histogram of 4.1}
        \centering
        \includegraphics[scale=0.7]{Q4/Q4(1).png}
    \end{figure}
\newpage
%--------------------------------  4.2  ------------------------------------
  \subsection*{4.2}
    \begin{framed}
        For 4.2, we follow the instructions given in the question. We first pick a direction/angle and assume an imaginary radius there. Then we pick a random point on that radius and find its distance from the origin $(0,0)$. This serves as our base, while to radius R serves as our hypotaneous. Then we find the perpendicular using the pythagorean theorem, and returns the twice of it. As the perpendicular shows the half part of that cord, with randomly chosen point as its center. This point is also the midpoint for our circle, so we double the perpendicular to find the whole cord length.
        \begin{center}
            \includegraphics[scale=0.7]{Q4/4.2_circle.png}
        \end{center}
        \begin{enumerate}
            \item \emph{random\_cord(R)}: This function does multiple tasks. It first find a random direction/angle in the circle, assumes a radius on that angle, and pick a random point on the assumed radius. This point serves as the Midpoint M as well. Then it converts the polar cordinates into cartesian using the following formulae,
                \begin{align*}
                    x &= rcos(\theta)\\
                    y &= rsin(\theta)
                \end{align*}
            Then we find our base b and perpendicular p, while assuming it is a right-angle triangle because \emph{p} and \emph{b} makes a right-angle triangle. In our case we assume the distance between the origin and the random point $(x,y)$ to be our base, and radius R as our hypotaneous. We use the \emph{distance formula} to find the value of base,\\
                \begin{align*}
                    base &= \sqrt{x^2+y^2}
                \end{align*}
            Then we find the value of perpendicular line by using the pythagorean theroem,\\
                \begin{align*}
                    perpendicular &= \sqrt{R^2-base^2}
                \end{align*}
            Then we simply multiply the value of perpendicular to find the length of the cord and return it.
            \item \emph{find\_cords2(R)}: This function runs 1000 iterations of the \emph{random\_cord(R)} function, and stores their result in the list \emph{cord\_len}, sets the bin width as 50, and then graphs the histogram as the result.
        \end{enumerate}
        We run this program with radius 30. The resulting histogram seems to be an exponentially rising graph, with a flat start.
    \end{framed}
    \lstinputlisting[firstline=35,lastline=73,language=python]{code/Q4.py}
    \begin{figure}[h]
        \caption{Histogram of 4.2}
        \centering
        \includegraphics[scale=0.7]{Q4/Q4(2).png}
    \end{figure}
\newpage
%--------------------------------  4.3  ------------------------------------
  \subsection*{4.3}
    \begin{framed}
        For 4.3, it is similar to 4.2 with a slight difference. Instead of determining a direction, we pick a random point in the circle, and then calculates its distance from the origin $(0,0)$. If the distance is within the circle as well, we regard it as our base/adjacent of the right triangle. Then we move towards calculating the opposite/perpendicular by using pythagorean theorem, multiply it by 2 to find the total length, and then store it in the list. Then we pass that list plotting functions to plot a histogram.
        \begin{enumerate}
            \item \emph{p\_to\_o(cord)}: This function simply returns the distance between the randomly chosen point and the origin $(0,0)$. It takes a tuple of cartesian cordinates as the input and returns the distance. It uses the distance formula,
                \begin{align*}
                    dist=\sqrt{x^2+y^2}
                \end{align*}
            \item \emph{random\_point(R)}: It chooses random points for cartesian cordinates $(x,y)$ between the R and -R.
            \item \emph{cal\_cord(R,pnt)}: It takes the randomly chosen point, and finds its distance from the origin, then uses it as the adjacent/base of our right-angle triangle within the circle. Then it finds the value of the opposite/perpendicular via pythagorean theorem, and returns the twice of the opposite as the cord length.
            \item \emph{find\_cords3(R)}: This function runs 1000 times while calling the \emph{random\_point(R)} function, then it checks if the distance/base lies within the circle or not. If it does, then it proceeds to find \emph{cal\_cord(R,pnt)} and store it, else it decrements the counter by 1, to discard that value and find another.
        \end{enumerate}
        We run this program for radius 20. The histogram looks quite linear.
    \end{framed}
    \lstinputlisting[firstline=74,lastline=119,language=python]{code/Q4.py}
    \begin{figure}[h]
        \caption{Histogram of 4.3}
        \centering
        \includegraphics[scale=0.7]{Q4/Q4(3).png}
    \end{figure}
\newpage
%--------------------------------  4.4  ------------------------------------
\subsection*{4.4}
    \begin{framed}
        Out of all the distributions, I think the third approach (part 4.3) is the best to take. Its graph seems somewhat linear, which will ensure a little uniformity. As the previous graphs showed dense distribution towards the center of the circle, i.e. near the diameter, however in 4.3, the graph seems more distributed.
    \end{framed}

% ------------------------------------------------- 5 -------------------------------------------------------------------
\pagebreak
\section*{Q5: Hypothesis Testing}
\subsection*{5.1}
\textbf{This question requires us to use hypothesis testing to determine whether the null hypothesis that a coin is fair is true or not. }\\
The following function implements the simulation of a fair coin:
\lstinputlisting[firstline=10,lastline=12,language=python]{code/q5.py}
This function then uses the above function to simulate 10 coin tosses 100 times and finds the expected number of times the null hypothesis is rejected for each iteration:
\lstinputlisting[firstline=14,lastline=35, language=python]{code/q5.py}
Histogram of expected values:
\begin{center}
  \includegraphics[scale = 0.5]{Q5/Q5.1.png}
\end{center}
Probability we will reject the null hypothesis even though it is true:\\
\emph{Simulation-wise}: According to the mean of the expected values, the probability is $2.3\%$.\\
\emph{Mathematically}: We reject the null hypothesis if the probability of the outcomes is below the threshold. Since the probability of the outcomes being accepted is 0.95 and the probability of them being rejected is 0.05, the probability that we reject the null hypothesis even though it is true is also 0.05 which is equal to the threshold.

\subsection*{5.2.1}
\textbf{This question requires us to use hypothesis testing to determine the validity of the null hypothesis that the mean length of fish in a lake is 23.}\footnote{The fish.pyc file we received was causing errors so we used the new fish.py file provided by a TA}\\
The following function conducts a single hypothesis test by taking a sample of $30$ fish and calculating the mean and standard deviation of their lengths to check the following condition to accept or reject the null hypothesis:
\[P(|S - u_0| \geq a) < 0.05\]
The function returns $1$ if the hypothesis is rejected, and $0$ if it is accepted.
\lstinputlisting[firstline=41,lastline=53,language=python]{code/q5.py}
The following function performs 50 experiments and uses the average of their outcome to calculate a single expected value. It repeats this for 100 iterations and plots a histogram of the expected values.
\lstinputlisting[firstline=56,lastline=72,language=python]{code/q5.py}
Histogram of expected values of the null hypothesis being rejected:
\begin{center}
  \includegraphics[scale = 0.5]{Q5/Q5.2.1.png}
\end{center}
The histogram follows a normal disttribution with mean 0.951 and variance 0.001. According to this, the null hypothesis is rejected $95\%$ of the times so it is false. A single hypothesis test may have been sufficient to accept or reject the null hypothesis as the variance is very low.

\subsection*{5.2.2}
The following function calls the \texttt{hypothesis\_test()} function defined in $5.2.1$ using the same value for the population mean $u_0$ $(23)$ but passing a value of 70 for the sample size $n$. It then performs 50 experiments and uses the average of their outcome to calculate a single expected value. It repeats this for 100 iterations and plots a histogram of the expected values.
\lstinputlisting[firstline=75,lastline=91,language=python]{code/q5.py}
Histogram of expected values of the null hypothesis being rejected:
\begin{center}
  \includegraphics[scale = 0.5]{Q5/Q5.2.2.png}
\end{center}
Increasing the value of $n$ made the variance become $0$ where it was previously 0.001. In other words, the null hypothesis is rejected $100\%$ of the times. A single hypothesis test may have been sufficient to reject the null hypothesis in this case as there is no variance in the outcome.

\subsection*{5.2.3}
\textbf{Determining the least value of $n$ to ensure that the null hypothesis is not wrongly rejected more than 10 percent of the time using simulations.}\\ 

The following is a function that returns the length of a fish following a normal distribution with mean 23 and standard deviation 3.
\lstinputlisting[firstline=96,lastline=97,language=python]{code/q5.py}

In order to calculate the expected number of times the null hypothesis is rejected, we use the following function which takes in the value of the population mean $u_0$ and sample size $n$ and uses the \texttt{my\_fish()} function defined above to create the sample for the test. It then conducts the test itself the same way as the previous parts but with a threshold of 0.1.
\lstinputlisting[firstline=99,lastline=111,language=python]{code/q5.py}

We then use the following function which calls the \texttt{testing()} function, performs 50 experiments and uses the average of their outcome to calculate a single expected value. It repeats this for 100 iterations and plots a histogram of the expected values.
\lstinputlisting[firstline=113,lastline=130,language=python]{code/q5.py}
\pagebreak
Conducting simulations with various values of $n$, we achieve the above histograms.
\begin{figure}
  \centering
  \mbox{\subfigure{\includegraphics[scale = 0.35]{Q5/Q5.2.3_85.png}}\quad
  \subfigure{\includegraphics[scale = 0.35]{Q5/Q5.2.3_90.png}}}
\end{figure}
\begin{figure}
  \centering
  \mbox{\subfigure{\includegraphics[scale = 0.35]{Q5/Q5.2.3_95(1).png}}\quad
  \subfigure{\includegraphics[scale = 0.35]{Q5/Q5.2.3_95(10).png}}}
\end{figure}
In order to determine the least value of $n$ to ensure that the null hypothesis is not wrongly rejected more than 10 percent of the times, we want a value of $n$ that gives a mean of 0.1. According to the simulations, the value of $n$ satisfying this condition is \textbf{90}. 

\end{document}